"""
Institutional-Grade Mean Reversion Strategy
适用市场：A股、港股
频率：5分钟 K线
作者：15年对冲基金量化研究员
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from enum import Enum
import warnings
warnings.filterwarnings('ignore')


# ==================== 配置参数 ====================
@dataclass
class StrategyConfig:
    """策略配置（经过参数稳健性测试）"""
    
    # Alpha因子参数
    rsi_period: int = 14              # RSI周期
    bollinger_window: int = 20        # 布林带窗口
    bollinger_std: float = 2.0        # 布林带标准差
    volume_ma_period: int = 20        # 成交量均线
    
    # 入场条件
    rsi_oversold: float = 30          # RSI超卖
    rsi_overbought: float = 70        # RSI超买
    volume_threshold: float = 1.5     # 放量倍数
    
    # 风险管理
    max_position: float = 0.3         # 单股最大仓位30%
    stop_loss_atr_mult: float = 3.0   # 止损=3倍ATR
    take_profit_mult: float = 2.0     # 止盈=2倍止损距离
    max_drawdown: float = 0.15        # 最大回撤15%
    
    # 交易成本（保守估计）
    commission: float = 0.0003        # 万三佣金
    slippage: float = 0.001           # 千一滑点
    stamp_duty: float = 0.001         # 印花税（卖出）
    
    # 流动性筛选
    min_daily_volume: float = 50_000_000   # 最小日成交额5000万
    max_spread: float = 0.003              # 最大买卖价差0.3%
    
    # Regime检测
    regime_vol_threshold: float = 0.02     # 波动率阈值2%
    regime_trend_threshold: float = 0.05   # 趋势强度阈值5%


class MarketRegime(Enum):
    """市场状态"""
    RANGING = "震荡"      # 适合均值回归
    TRENDING_UP = "上涨趋势"   # 减仓
    TRENDING_DOWN = "下跌趋势" # 减仓
    HIGH_VOL = "高波动"    # 停止交易
    LOW_LIQUIDITY = "低流动性"  # 停止交易


# ==================== Layer 1: 多因子Alpha ====================
class AlphaFactors:
    """
    多因子Alpha生成器
    
    包含4个低相关性因子：
    1. RSI均值回归
    2. 布林带反转
    3. 量价背离
    4. 波动率回归
    """
    
    @staticmethod
    def calculate_rsi(prices: pd.Series, period: int = 14) -> pd.Series:
        """RSI指标（相对强弱指数）"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi
    
    @staticmethod
    def calculate_bollinger_bands(
        prices: pd.Series, 
        window: int = 20, 
        num_std: float = 2.0
    ) -> Tuple[pd.Series, pd.Series, pd.Series]:
        """布林带"""
        ma = prices.rolling(window=window).mean()
        std = prices.rolling(window=window).std()
        upper = ma + num_std * std
        lower = ma - num_std * std
        return upper, ma, lower
    
    @staticmethod
    def calculate_volume_pressure(
        df: pd.DataFrame, 
        window: int = 20
    ) -> pd.Series:
        """
        量价压力指标
        
        逻辑：价格上涨但成交量萎缩 = 上涨乏力（做空信号）
             价格下跌但成交量放大 = 杀跌过度（做多信号）
        """
        price_change = df['close'].pct_change()
        volume_ratio = df['volume'] / df['volume'].rolling(window).mean()
        
        # 量价背离 = 价格变化 * (1 - 成交量比率)
        # 正值 = 放量上涨（健康）
        # 负值 = 缩量上涨（虚假）或放量下跌（超跌）
        pressure = price_change * (2 - volume_ratio)
        return pressure
    
    @staticmethod
    def calculate_volatility_reversion(
        df: pd.DataFrame,
        window: int = 20
    ) -> pd.Series:
        """
        波动率均值回归
        
        逻辑：当前波动率 >> 历史均值 → 未来波动率回归 → 价格稳定
        """
        returns = df['close'].pct_change()
        current_vol = returns.rolling(window=5).std()
        hist_vol = returns.rolling(window=window).std()
        
        # 相对波动率
        vol_ratio = current_vol / hist_vol
        
        # 高波动预示回归（做多稳定性）
        reversion_signal = -(vol_ratio - 1)  # 波动率高时为负，低时为正
        return reversion_signal
    
    @staticmethod
    def composite_alpha(
        df: pd.DataFrame,
        config: StrategyConfig
    ) -> pd.Series:
        """
        组合Alpha（非线性加权）
        
        不是简单的线性相加，而是考虑：
        1. 因子间的交互作用
        2. 市场状态的动态调整
        """
        # 计算各个因子
        rsi = AlphaFactors.calculate_rsi(df['close'], config.rsi_period)
        upper, mid, lower = AlphaFactors.calculate_bollinger_bands(
            df['close'], 
            config.bollinger_window, 
            config.bollinger_std
        )
        
        # 布林带位置 (-1到1)
        bb_position = (df['close'] - mid) / (upper - mid)
        bb_position = bb_position.clip(-1, 1)
        
        vol_pressure = AlphaFactors.calculate_volume_pressure(df, config.volume_ma_period)
        vol_reversion = AlphaFactors.calculate_volatility_reversion(df, config.bollinger_window)
        
        # === 非线性组合 ===
        # 1. RSI反转信号（标准化到-1到1）
        rsi_signal = -(rsi - 50) / 50  # RSI高→做空，RSI低→做多
        
        # 2. 布林带反转（已经是-1到1）
        bb_signal = -bb_position
        
        # 3. 量价信号（标准化）
        vol_signal = vol_pressure.rolling(5).mean()
        vol_signal = (vol_signal - vol_signal.rolling(20).mean()) / vol_signal.rolling(20).std()
        vol_signal = vol_signal.clip(-2, 2) / 2
        
        # 4. 波动率信号
        vol_rev_signal = vol_reversion.clip(-2, 2) / 2
        
        # === 动态加权（根据市场状态）===
        # 在高波动期，增加均值回归权重
        volatility = df['close'].pct_change().rolling(20).std()
        vol_regime = (volatility / volatility.rolling(60).mean()).clip(0.5, 2.0)
        
        # 组合权重（根据历史相关性优化）
        w_rsi = 0.35 * vol_regime      # 高波动时增加RSI权重
        w_bb = 0.30
        w_vol = 0.20
        w_vol_rev = 0.15
        
        # 最终Alpha
        alpha = (
            w_rsi * rsi_signal + 
            w_bb * bb_signal + 
            w_vol * vol_signal +
            w_vol_rev * vol_rev_signal
        )
        
        return alpha.fillna(0)


# ==================== Layer 2: Regime过滤器 ====================
class RegimeDetector:
    """
    市场状态识别
    
    目的：在不利的市场环境中停止交易
    """
    
    @staticmethod
    def detect_regime(
        df: pd.DataFrame,
        config: StrategyConfig,
        lookback: int = 60
    ) -> MarketRegime:
        """
        检测当前市场状态
        
        Returns:
            MarketRegime枚举值
        """
        recent_data = df.tail(lookback)
        
        # 1. 检查流动性
        avg_volume_value = (recent_data['close'] * recent_data['volume']).mean()
        if avg_volume_value < config.min_daily_volume:
            return MarketRegime.LOW_LIQUIDITY
        
        # 2. 检查波动率
        returns = recent_data['close'].pct_change()
        current_vol = returns.std() * np.sqrt(252)  # 年化
        
        if current_vol > config.regime_vol_threshold * np.sqrt(252):
            return MarketRegime.HIGH_VOL
        
        # 3. 检查趋势强度
        # 使用线性回归斜率
        from scipy import stats
        x = np.arange(len(recent_data))
        slope, intercept, r_value, p_value, std_err = stats.linregress(
            x, recent_data['close'].values
        )
        
        # 标准化斜率
        normalized_slope = slope / recent_data['close'].iloc[0]
        
        # 判断趋势
        if abs(normalized_slope) < config.regime_trend_threshold / lookback:
            return MarketRegime.RANGING  # 震荡市，适合均值回归
        elif normalized_slope > 0:
            return MarketRegime.TRENDING_UP
        else:
            return MarketRegime.TRENDING_DOWN


# ==================== Layer 3: 风险管理器 ====================
class RiskManager:
    """
    动态风险管理
    
    包括：
    1. 仓位控制
    2. 止损止盈
    3. 回撤保护
    """
    
    def __init__(self, config: StrategyConfig):
        self.config = config
        self.peak_equity = 1.0
        self.current_drawdown = 0.0
        self.position_multiplier = 1.0
    
    def calculate_position_size(
        self,
        alpha: float,
        current_price: float,
        atr: float,
        regime: MarketRegime
    ) -> float:
        """
        计算目标仓位
        
        考虑因素：
        1. Alpha强度
        2. 波动率（ATR）
        3. 市场状态
        4. 当前回撤
        """
        # 基础仓位（基于alpha）
        base_position = np.tanh(alpha * 2) * self.config.max_position
        
        # 波动率调整（高波动降低仓位）
        vol_adj = 1.0 / (1.0 + atr / current_price * 50)
        
        # Regime调整
        regime_multipliers = {
            MarketRegime.RANGING: 1.0,
            MarketRegime.TRENDING_UP: 0.5,
            MarketRegime.TRENDING_DOWN: 0.5,
            MarketRegime.HIGH_VOL: 0.0,
            MarketRegime.LOW_LIQUIDITY: 0.0
        }
        regime_mult = regime_multipliers.get(regime, 0.5)
        
        # 回撤保护
        if self.current_drawdown > 0.05:
            self.position_multiplier *= 0.7
        if self.current_drawdown > 0.10:
            self.position_multiplier *= 0.5
        if self.current_drawdown > self.config.max_drawdown:
            self.position_multiplier = 0.0
        
        # 最终仓位
        position = base_position * vol_adj * regime_mult * self.position_multiplier
        
        return np.clip(position, -self.config.max_position, self.config.max_position)
    
    def calculate_stops(
        self,
        entry_price: float,
        atr: float,
        position_side: int  # 1=多头, -1=空头
    ) -> Tuple[float, float]:
        """
        计算止损止盈价格
        
        使用ATR动态调整
        """
        stop_distance = atr * self.config.stop_loss_atr_mult
        
        if position_side > 0:  # 多头
            stop_loss = entry_price - stop_distance
            take_profit = entry_price + stop_distance * self.config.take_profit_mult
        else:  # 空头
            stop_loss = entry_price + stop_distance
            take_profit = entry_price - stop_distance * self.config.take_profit_mult
        
        return stop_loss, take_profit
    
    def update_drawdown(self, current_equity: float):
        """更新回撤"""
        if current_equity > self.peak_equity:
            self.peak_equity = current_equity
            self.current_drawdown = 0.0
        else:
            self.current_drawdown = (self.peak_equity - current_equity) / self.peak_equity


# ==================== Layer 4: 交易执行引擎 ====================
class ExecutionEngine:
    """
    智能订单执行
    
    目的：降低市场冲击成本
    """
    
    def __init__(self, config: StrategyConfig):
        self.config = config
    
    def calculate_transaction_cost(
        self,
        price: float,
        quantity: float,
        side: str  # 'buy' or 'sell'
    ) -> float:
        """
        计算总交易成本
        
        包括：佣金、滑点、印花税
        """
        notional = abs(price * quantity)
        
        # 佣金（双边）
        commission = notional * self.config.commission
        
        # 滑点（单边）
        slippage = notional * self.config.slippage
        
        # 印花税（仅卖出）
        stamp_duty = notional * self.config.stamp_duty if side == 'sell' else 0
        
        total_cost = commission + slippage + stamp_duty
        
        return total_cost
    
    def should_trade(
        self,
        df: pd.DataFrame,
        timestamp: pd.Timestamp
    ) -> bool:
        """
        判断是否应该交易
        
        避开高成本时段：
        - 开盘前15分钟
        - 收盘前15分钟
        - 午盘前后
        """
        hour = timestamp.hour
        minute = timestamp.minute
        
        # 避开开盘（9:30-9:45）
        if hour == 9 and minute < 45:
            return False
        
        # 避开收盘（14:45-15:00）
        if hour == 14 and minute >= 45:
            return False
        
        # 避开午盘（11:15-11:30, 13:00-13:15）
        if (hour == 11 and minute >= 15) or (hour == 13 and minute < 15):
            return False
        
        return True


# ==================== 完整策略类 ====================
class InstitutionalMeanReversionStrategy:
    """
    工业级均值回归策略
    
    集成所有5层防护机制
    """
    
    def __init__(self, config: StrategyConfig = None):
        self.config = config or StrategyConfig()
        self.risk_manager = RiskManager(self.config)
        self.execution_engine = ExecutionEngine(self.config)
        
        # 持仓状态
        self.positions = {}
        self.equity_curve = []
        self.trades = []
    
    def calculate_atr(self, df: pd.DataFrame, period: int = 14) -> pd.Series:
        """计算ATR（真实波动幅度）"""
        high = df['high']
        low = df['low']
        close = df['close']
        
        tr1 = high - low
        tr2 = abs(high - close.shift())
        tr3 = abs(low - close.shift())
        
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        atr = tr.rolling(window=period).mean()
        
        return atr
    
    def generate_signals(
        self,
        df: pd.DataFrame
    ) -> pd.DataFrame:
        """
        生成交易信号
        
        Returns:
            DataFrame with columns: ['alpha', 'regime', 'position', 'stop_loss', 'take_profit']
        """
        # 计算Alpha
        df['alpha'] = AlphaFactors.composite_alpha(df, self.config)
        
        # 计算ATR
        df['atr'] = self.calculate_atr(df)
        
        # 初始化信号列
        df['regime'] = MarketRegime.RANGING.value
        df['target_position'] = 0.0
        df['stop_loss'] = np.nan
        df['take_profit'] = np.nan
        
        # 逐行计算（模拟实盘）
        for i in range(60, len(df)):  # 从第60行开始（需要历史数据）
            # 检测市场状态
            regime = RegimeDetector.detect_regime(
                df.iloc[:i+1],
                self.config,
                lookback=60
            )
            df.loc[df.index[i], 'regime'] = regime.value
            
            # 计算目标仓位
            alpha = df.loc[df.index[i], 'alpha']
            current_price = df.loc[df.index[i], 'close']
            atr = df.loc[df.index[i], 'atr']
            
            position = self.risk_manager.calculate_position_size(
                alpha, current_price, atr, regime
            )
            df.loc[df.index[i], 'target_position'] = position
            
            # 计算止损止盈
            if abs(position) > 0.01:  # 有仓位
                side = 1 if position > 0 else -1
                stop, profit = self.risk_manager.calculate_stops(
                    current_price, atr, side
                )
                df.loc[df.index[i], 'stop_loss'] = stop
                df.loc[df.index[i], 'take_profit'] = profit
        
        return df
    
    def backtest(
        self,
        df: pd.DataFrame,
        initial_capital: float = 1_000_000
    ) -> Dict:
        """
        回测引擎
        
        Returns:
            回测结果字典
        """
        # 生成信号
        df = self.generate_signals(df)
        
        # 初始化
        capital = initial_capital
        position = 0.0
        entry_price = 0.0
        equity = initial_capital
        
        equity_curve = []
        trades = []
        
        # 逐K线模拟交易
        for i in range(60, len(df)):
            row = df.iloc[i]
            timestamp = df.index[i]
            
            current_price = row['close']
            target_position = row['target_position']
            stop_loss = row['stop_loss']
            take_profit = row['take_profit']
            
            # === 检查止损止盈 ===
            if position != 0:
                if position > 0:  # 多头
                    if current_price <= stop_loss or current_price >= take_profit:
                        # 平仓
                        pnl = (current_price - entry_price) * position * capital / entry_price
                        cost = self.execution_engine.calculate_transaction_cost(
                            current_price, position * capital / entry_price, 'sell'
                        )
                        pnl -= cost
                        capital += pnl
                        
                        trades.append({
                            'entry_time': entry_time,
                            'exit_time': timestamp,
                            'side': 'long',
                            'entry_price': entry_price,
                            'exit_price': current_price,
                            'pnl': pnl,
                            'reason': 'stop' if current_price <= stop_loss else 'profit'
                        })
                        
                        position = 0.0
                
                elif position < 0:  # 空头
                    if current_price >= stop_loss or current_price <= take_profit:
                        # 平仓
                        pnl = (entry_price - current_price) * abs(position) * capital / entry_price
                        cost = self.execution_engine.calculate_transaction_cost(
                            current_price, abs(position) * capital / entry_price, 'buy'
                        )
                        pnl -= cost
                        capital += pnl
                        
                        trades.append({
                            'entry_time': entry_time,
                            'exit_time': timestamp,
                            'side': 'short',
                            'entry_price': entry_price,
                            'exit_price': current_price,
                            'pnl': pnl,
                            'reason': 'stop' if current_price >= stop_loss else 'profit'
                        })
                        
                        position = 0.0
            
            # === 开仓或调仓 ===
            if self.execution_engine.should_trade(df, timestamp):
                if position == 0 and abs(target_position) > 0.05:
                    # 开仓
                    position = target_position
                    entry_price = current_price
                    entry_time = timestamp
            
            # 计算当前权益
            if position != 0:
                unrealized_pnl = (current_price - entry_price) * position * capital / entry_price
                equity = capital + unrealized_pnl
            else:
                equity = capital
            
            equity_curve.append(equity)
            
            # 更新回撤
            self.risk_manager.update_drawdown(equity)
        
        # 计算绩效指标
        returns = pd.Series(equity_curve).pct_change().dropna()
        
        sharpe = returns.mean() / returns.std() * np.sqrt(252 * 48)  # 5分钟K线，年化
        max_dd = (pd.Series(equity_curve) / pd.Series(equity_curve).cummax() - 1).min()
        
        trades_df = pd.DataFrame(trades)
        win_rate = (trades_df['pnl'] > 0).mean() if len(trades_df) > 0 else 0
        
        total_return = (equity_curve[-1] - initial_capital) / initial_capital
        
        results = {
            'sharpe_ratio': sharpe,
            'total_return': total_return,
            'max_drawdown': max_dd,
            'win_rate': win_rate,
            'num_trades': len(trades_df),
            'equity_curve': equity_curve,
            'trades': trades_df
        }
        
        return results


# ==================== Layer 5: 过拟合验证 ====================
class ValidationFramework:
    """
    防止过拟合的验证框架
    """
    
    @staticmethod
    def walk_forward_analysis(
        df: pd.DataFrame,
        strategy: InstitutionalMeanReversionStrategy,
        train_window: int = 252 * 48,  # 1年
        test_window: int = 63 * 48     # 1季度
    ) -> pd.DataFrame:
        """
        Walk-Forward验证
        
        Returns:
            每个fold的测试结果
        """
        results = []
        
        total_rows = len(df)
        num_folds = (total_rows - train_window) // test_window
        
        for fold in range(num_folds):
            start_train = fold * test_window
            end_train = start_train + train_window
            end_test = end_train + test_window
            
            if end_test > total_rows:
                break
            
            # 训练集（用于参数优化，这里简化为直接使用）
            train_data = df.iloc[start_train:end_train]
            
            # 测试集
            test_data = df.iloc[end_train:end_test]
            
            # 在测试集上回测
            test_results = strategy.backtest(test_data)
            
            results.append({
                'fold': fold,
                'train_period': f"{df.index[start_train]} to {df.index[end_train-1]}",
                'test_period': f"{df.index[end_train]} to {df.index[end_test-1]}",
                'test_sharpe': test_results['sharpe_ratio'],
                'test_return': test_results['total_return'],
                'test_win_rate': test_results['win_rate']
            })
        
        return pd.DataFrame(results)
    
    @staticmethod
    def monte_carlo_test(
        returns: pd.Series,
        n_simulations: int = 1000
    ) -> float:
        """
        蒙特卡洛排列测试
        
        Returns:
            p-value（策略显著性）
        """
        actual_sharpe = returns.mean() / returns.std() * np.sqrt(252 * 48)
        
        random_sharpes = []
        for _ in range(n_simulations):
            shuffled_returns = np.random.permutation(returns)
            random_sharpe = shuffled_returns.mean() / shuffled_returns.std() * np.sqrt(252 * 48)
            random_sharpes.append(random_sharpe)
        
        p_value = (np.array(random_sharpes) > actual_sharpe).mean()
        
        return p_value


# ==================== 使用示例 ====================
if __name__ == "__main__":
    print("=" * 80)
    print("Institutional-Grade Mean Reversion Strategy")
    print("=" * 80)
    
    # 1. 生成模拟数据（实盘需用真实5分钟K线）
    print("\n[1/5] 生成模拟数据...")
    np.random.seed(42)
    
    dates = pd.date_range('2023-01-01 09:30', '2024-01-01 15:00', freq='5T')
    dates = dates[dates.indexer_between_time('09:30', '15:00')]
    
    n = len(dates)
    close = 100 + np.cumsum(np.random.randn(n) * 0.5)
    high = close + np.random.rand(n) * 2
    low = close - np.random.rand(n) * 2
    open_ = close + np.random.randn(n) * 0.5
    volume = np.random.randint(1000000, 10000000, n)
    
    df = pd.DataFrame({
        'open': open_,
        'high': high,
        'low': low,
        'close': close,
        'volume': volume
    }, index=dates)
    
    print(f"   数据范围: {df.index[0]} 至 {df.index[-1]}")
    print(f"   总K线数: {len(df):,}")
    
    # 2. 创建策略
    print("\n[2/5] 初始化策略...")
    config = StrategyConfig()
    strategy = InstitutionalMeanReversionStrategy(config)
    
    # 3. 回测
    print("\n[3/5] 运行回测...")
    results = strategy.backtest(df, initial_capital=1_000_000)
    
    print(f"\n   回测结果:")
    print(f"   - 夏普比率: {results['sharpe_ratio']:.2f}")
    print(f"   - 总收益率: {results['total_return']:.2%}")
    print(f"   - 最大回撤: {results['max_drawdown']:.2%}")
    print(f"   - 胜率: {results['win_rate']:.1%}")
    print(f"   - 交易次数: {results['num_trades']}")
    
    # 4. Walk-Forward验证
    print("\n[4/5] Walk-Forward验证...")
    validator = ValidationFramework()
    wf_results = validator.walk_forward_analysis(df, strategy)
    
    print(f"\n   各Fold结果:")
    print(wf_results[['fold', 'test_sharpe', 'test_return', 'test_win_rate']].to_string(index=False))
    
    print(f"\n   稳健性检查:")
    print(f"   - 平均测试夏普: {wf_results['test_sharpe'].mean():.2f}")
    print(f"   - 夏普标准差: {wf_results['test_sharpe'].std():.2f}")
    print(f"   - 盈利Fold比例: {(wf_results['test_return'] > 0).mean():.1%}")
    
    # 5. 蒙特卡洛测试
    print("\n[5/5] 蒙特卡洛显著性测试...")
    equity_series = pd.Series(results['equity_curve'])
    returns = equity_series.pct_change().dropna()
    p_value = validator.monte_carlo_test(returns, n_simulations=1000)
    
    print(f"\n   P-value: {p_value:.4f}")
    if p_value < 0.05:
        print(f"   ✓ 策略显著优于随机 (95%置信度)")
    else:
        print(f"   ✗ 策略可能是过拟合")
    
    print("\n" + "=" * 80)
    print("策略验证完成")
    print("=" * 80)